<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth First Search and Depth First Search</title>
</head>
<style>
    html{
        background:white;
    
    }
    h1{
        text-align: center;
        padding: 30px;
        padding-top:3 0px;
        color:white;
        background-color:black ;
        font-size:30px;
    
    
    }
    p{
        font-size: 20px;

    }
    h2{
        font-size: 30px;
        text-decoration: underline;
        text-align: center;
    }
    img{
        padding-left:390px;
        padding-top:30px;
    }
    ul li{
        font-size: 20px;
    }
    .reveal{
        position: relative;
        transform: translateY(150px);
        opacity: 0;
        transition: all 3s ease;
    }
    .reveal.active{
        transform: translatey(0px);
        opacity: 1;
    }
</style>
<body>
    <h1>Breadth First Search and Depth First Search</h1>
    <h2>Breadth First Search</h2>
    <p>The breadth-first search (BFS) algorithm is used to search a tree or graph data structure for a node that meets a set of criteria. It starts at the tree’s root or graph and searches/visits all nodes at the current depth level before moving on to the nodes at the next depth level. Breadth-first search can be used to solve many problems in graph theory.</p>
   <h2> Algorithm of Breadth-First Search:</h2>
    <ul>
<li>Step 1: Consider the graph you want to navigate.</li>
<li>Step 2: Select any vertex in your graph (say v1), from which you want to traverse the graph.</li>
<li>Step 3: Utilize the following two data structures for traversing the graph.Visited array(size of the graph)Queue data structure</li>
<li>Step 4: Add the starting vertex to the visited array, and afterward, you add v1’s adjacent vertices to the queue data structure.</li>
<li>Step 5: Now using the FIFO concept, remove the first element from the queue, put it into the visited array, and then add the adjacent vertices of the removed element to the queue.</li>
<li>Step 6: Repeat step 5 until the queue is not empty and no vertex is left to be visited.</li></ul>
<section>
    <div class="reveal active">
    <img src="tree1.gif"width="550px"height="350px">
</div>
</section>
<h2>Depth first search</h2>
<p>Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array. A graph can have more than one DFS traversal.</p>
<h2>Algorithm of Depth-First Search:</h2>
<ul>
    <li>Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree.</li>
    <li> The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice).</li>
    <li> To avoid processing a node more than once, use a boolean visited array.</li>
    <li> A graph can have more than one DFS traversal.</li>
</ul>
<section>
    <div class="reveal active">
    <img src="tree2.gif"width="550px"height="350px">
</div>
</section>
<script type="text/javascript">
    window.addEventListener('scroll', reveal);

    function reveal() {
        var reveals = document.querySelectorAll('.reveal');
        for (var i = 0; i < reveals.length; i++) {
            var windowheight = window.innerHeight;
            var revealtop = reveals[i].getBoundingClientRect().top;
            var revealpoint = 150;
            if (revealtop < windowheight - revealpoint) {
                reveals[i].classList.add('active');
            }
            else {
                reveals[i].classList.remove('active');
            }
        }

    }
</script>

    
</body>
</html>